[{"content":"Title should be defined As soon as I started working with Java I found some curious things. I‚Äôve never evolved with a language that requires thorough care with memory as well as a language where it is needed to configure virtual machine resources and everything else. That is not criticism, maybe I‚Äôve never been so deeply into a programming language to need to understand exactly how their core persists data into memory. I worked with Ruby, PHP and Go (for a small period of time), as well I have fun with Python sometimes and, at least from what I know, they do not have any complex memory management system.\nThe thing is that last month I was working on an application that will receive a huge amount of requests and sometimes I noticed that the application instance restarts without any clear problem so I went to learn more about how Java and JVM manage memory because the first thing I thought was a memory problem.\nWhy did I suspect memory problems? Well, I saw some GC Minor running slowly into our datadog metrics so I assumed that they are consuming too much time to clear the heap memory application, so slow that degraded application instance forcing our PaaS to an instance recycle.\nOk. But the problem itself it‚Äôs not the subject of this article. The problem forced me to understand more about core java memory management, and this blog purpose is to share with the internet my learnings and achievements, so let‚Äôs talk about java memory management system.\nWhat is Java Virtual Machine and How It Works? Java Virtual Machine is nothing more than a computer program that gets your java classes and transforms it into bytecode which will allow the PC to read and run any algorithm. The first thing I thought when I learned about JVM is that this is a compiler‚Ä¶ But not exactly. JVM turns your Java code into bytecode which is interpreted, so Java is a semi-compiled language. So JVM acts more as a translator than a compiler.\nWe can abstract JVM in three main components:\nClass Loader: responsible to load all classes and save them into Metaspace memory, don‚Äôt care about this name for now, we‚Äôll talk about Metaspace later; Runtime Data Areas: probably the most important component of JVM, the is where all data are stored; Execution Engine: where the class file turns into bytecode. We will talk about metaspace in a while, for know I think it is enough to know that class loader is the component responsible to get our class files metadata and load all their data. The second component of JVM , and probably the most important, is Runtime Data Areas.\nRuntime Data Areas It is a logical division of disponible memory resources for JVM. What I mean is that when we configure a new java app, the app will run inside a Java Virtual Machine, so this virtual machine has a memory allowed to use and Runtime Data Areas is a logical division of the disponible resource.\nEach area is responsible to store determined kinds of information:\nStack: each java thread has its own stack memory space to store primitive or reference variables. The heap: here is where any object is stored, so every time you write the new keyword into your code, the JVM will persist the instance object inside the heap memory area; The metaspace: there is where all classes metadata will be stored; PC Counter: known as Program Counter Register, here, the JVM will store where each thread is working, this system allow concurrency in Java; Native Method Stack: also known as a C stack, is used when our code uses any native method. There are a lot of subjects to talk about here, and probably I‚Äôll need some more posts to cover everything. So this article will be a series of articles, and this is the first one. Here we will cover two runtime data areas with more details: the stack and heap.\nWhat about stack? Earlier I said that I had a San Francisco Giants baseball on my table. Through lifelong learning, my brain has successfully associated the name \u0026ldquo;San Francisco Giants baseball\u0026rdquo; with the corresponding object. Also, speaking about human brains, there some logical division on them too:\nAs we can see, the human brain is divided by science in some areas: frontal lobe, parietal lobe, occipital lobe, temporal lobe and cerebellum. For sure, each one of these areas has its own responsibility and works to solve a specific problem that the evolution of humans discovered. Hum‚Ä¶ we were talking about JVM stack areas and now are we talking about human brains?\nYep. And I made this analogy because the JVM stack area is the area responsible to maintain and organize the relationship between a variable and its value. When I say its value, I mean the object reference or the value itself if it is a primitive value. As well my brain maintains a relationship that allows me to know that my San Francisco Giants Baseball is that object on my desk.\nIt is important to know that each thread has its own stack space on memory. Inside its space we can have two kinds of data stored: primitive data types which are the value itself directly stored into stack area or reference data types that are only the address to a previously created object stored into heap. We‚Äôll talk about the heap memory later.\nSo‚Ä¶ The stack area creates these links between the execution and stored objects which will allow the program to run well. This could lead to a lot of new questions, like: ok, I understand how java creates a relationship between the code that has been executing and the objects stored on the heap, but it will grow forever? who clean it? only objects are stored in the heap? etc‚Ä¶\nThis subject isn‚Äôt trivial and isn‚Äôt small. So each step we learn will lead us to more and more questions. These questions will help us to understand more about the language and its core. And this knowledge will lead us to be better software engineers. So these questions are important and I hope I could help you to answer them.\nNot only object will be stored into heap The first time I read about this I thought: ‚Äúok, the heap only stores objects‚Äù. Although, it is not exactly true. Because if you have a primitive data type inside the object it will be stored into the heap, obviously wrapped with the whole object.\n1class Baseball { 2 int size = 12; 3 String color = \u0026#34;white\u0026#34;; 4 String team = \u0026#34;giants\u0026#34;; 5 6 public String pitch() { 7 return \u0026#34;threw the ball at a speed of 90mph\u0026#34;; 8 } 9} 10 11public class Main { 12 public static void main(String[] args) { 13 Baseball ball = new Baseball(); 14 System.out.println(ball); 15 } 16} I mean that, in the example, the size isn‚Äôt a primitive data type, but it is stored into the heap memory. So what I want to share is that it isn\u0026rsquo;t necessary that every primitive data type will be only stored into stack memory.\nIt‚Äôs time to learn about frames We haven‚Äôt talked about frames yet. The thing is that the stack does not store only variables, the stack frames too. A frame is a space allocated into the stack for each method into our object. Back in the baseball example we have a single thread to execute the whole code, this thread has its own stack space (we talked about earlier), inside the stack JVM will create a frame to the main method and push it to the stack. As we instantiate Baseball class, JVM will create this object into the heap and return the address which will be stored into the current frame.\nNow let‚Äôs say we execute the method pitch after instantiating a Baseball object, JVM will create a new frame and push it to the thread‚Äôs stack space. This new frame will be now the current frame and a variable will be stored inside: ‚Äúthrew the ball at a speed of 90mph‚Äù.\nAs soon as the method execution is finished JVM will pop the current frame and back executing the previous frame, that will be now the current frame.\nStackOverFlow Now we know how the stack works, it‚Äôs simple to understand what leads us to a stack overflow error. Imagine a water bottle filling under a tap, but somehow the bottle is closed. The bottle is made of plastic, and as it fills up the pressure increases, at some point it will burst because it can‚Äôt hold any more.\nSo the stack overflow error is this exact case: our JVM does not have more resources to store new frames.\nIt was true, we will talk about heap spaces! At this moment, I hope you have understood, at least superficially how the JVM works, as well about the stack. So we understood how JVM relates the variable to an object stored in a heap. But what is the heap itself? I know we didn‚Äôt deeply talk about heap, but I think you already know based on our earlier subject in this post.\nThe heap is the memory space reserved to store objects. So everytime we use the keyword new, we‚Äôre saying to JVM create a new object based on a class and persist the object into the heap memory. As we saw on figure 6. After saving the object, it will return the object address to be saved into the thread‚Äôs stack space.\nThe heap memory space is divided into two parts, the first one is the young generation space and the second one is the tenured space, known as old generation space. Each one has its own specific usage by the JVM and we will discuss both in this article. But first, let‚Äôs talk about the first one: the young generation.\nWe‚Äôre all young, or not anymore. When I was younger I was able to be in front of a computer for hours and hours, mostly gaming. Nowadays I work about 8 hours looking at a screen and my eyes hurt. Probably because I‚Äôm 15 years older than that time.\nWhat happens inside the heap is: when a new object is created the JVM will allocate this new object into the young generation and for each time the garbage collector runs (yes, this is new in this article) he will increment the age counter to all objects. Like when I was 15 and on my birthday the world incremented one more year to my age.\nAfter some birthdays (garbage collector runs), he will move the objects from the young generation to the old generation.\nLet‚Äôs dive into young space But before we talk about old generations, let\u0026rsquo;s deep dive a bit into the young generation space and how it works. First of all I need to say: the young generation is divided too. There are two spaces into the young generation, the Eden space and the survivor space.\nSo, as we can see, the heap memory splits into two spaces: young and old generations. The young generations split into other two spaces: the eden and the survivor space.\nThe eden space will receive any new object, and now, we will start to understand how the garbage collector works: when the eden space is full, JVM will start running the garbage collector, which is the process responsible to manage the objects, moving and cleaning spaces to allow the program to allocate new objects.\nSo, when the eden space is full, the garbage collector will run. The first step of the garbage collector is to mark all the objects which have any active reference in the stack variables. After this the gc will move all live objects from the eden to the survivor and deallocate all objects that do not have marks, I mean, objects which do not have any reference. This is the Minor GC.\nWell, minor and major gc are a world and I believe there is enough for this article, for sure there will be more articles about JVM and Memory Management System. If you don‚Äôt know why I created this blog, I invite you to read my first blog post. I hope you learned something.\nhttps://docs.oracle.com/javase/tutorial/java/concepts/object.html\nhttps://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\nhttps://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html\n","permalink":"http://localhost:1313/posts/jvm-deep-dive-stack-heap/","summary":"\u003ch1 id=\"title-should-be-defined\"\u003eTitle should be defined\u003c/h1\u003e\n\u003cp\u003eAs soon as I started working with Java I found some curious things. I‚Äôve never evolved with a language that requires thorough care with memory as well as a language where it is needed to configure virtual machine resources and everything else. That is not criticism, maybe I‚Äôve never been so deeply into a programming language to need to understand exactly how their core persists data into memory. I worked with Ruby, PHP and Go (for a small period of time), as well I have fun with Python sometimes and, at least from what I know, they do not have any complex memory management system.\u003c/p\u003e","title":"JVM Deep Dive: Understanding Stack and Heap Memory"},{"content":"Having worked as a software engineer since 2012, I\u0026rsquo;ve gained experience across various domains including WordPress, Laravel, Ruby on Rails, backend, and frontend development. This year, I embarked on a new and exciting challenge as a backend software engineer at a prominent South American tech company, collaborating with a team of highly experienced professionals. The project, centered around a \u0026ldquo;feature store\u0026rdquo;‚Äîa concept new to me before joining‚Äîhas presented novel challenges.\nFor those unfamiliar with feature stores, let\u0026rsquo;s first clarify what a feature is. A feature is a characteristic that describes an object, typically the subject of your study. These features are then utilized to train machine learning models or to make predictions based on them.\nFeature engineering in machine learning is a crucial step for the success of the entire process. For me, coming from the backend, the \u0026ldquo;feature store\u0026rdquo; is a fascinating component. It functions as a central data API for ML, needing to serve features with very low latency for real-time predictions (like a cache) and, at the same time, provide large volumes of historical data for model training (like a data warehouse). The real challenge lies in building and maintaining data pipelines (ETLs) that feed this store reliably and consistently. This is Data Engineering in practice.\nSource: Towards Data Science - Every Step of the Machine Learning Life Cycle Simply Explained\nThis exposure and the motivation to deepen my understanding of data engineering have inspired me to initiate a personal project focused on a data engineering career transition. To further this goal, I recently enrolled in a postgraduate program with a strong foundation in statistics. I\u0026rsquo;m thoroughly enjoying this course and am optimistic about the growing market for data engineering, a trend evident in Google\u0026rsquo;s search data.\nMy pursuit of a data science analytics course, grounded in statistical principles, stems from a desire to comprehend the entire data science ecosystem. My goal is to specialize in data engineering, and understanding the broader field, including its statistical foundations, is crucial for this. In an era where large language models are increasingly capable of generating code, a solid knowledge base, particularly in statistics, becomes even more essential.\nStatistical thinking has offered surprising insights, such as methods to enhance presentations and critical analysis skills. Furthermore, I\u0026rsquo;ve observed striking parallels between software engineering and data science learning, particularly in their foundational elements. Just as algorithms and data structures were fundamental when I began learning software development, they form the bedrock of many data science concepts, like trees.\nWatch the commercial here: Schlitz vs Michelob - Super Bowl XV 1981\nThis commercial, cited in a renowned statistical book by Charles Wheelan, perfectly illustrates how statistics can be both entertaining and crucial.\n","permalink":"http://localhost:1313/posts/statistics-foundation-data-engineering/","summary":"\u003cp\u003eHaving worked as a software engineer since 2012, I\u0026rsquo;ve gained experience across various domains including WordPress, Laravel, Ruby on Rails, backend, and frontend development. This year, I embarked on a new and exciting challenge as a backend software engineer at a prominent South American tech company, collaborating with a team of highly experienced professionals. The project, centered around a \u0026ldquo;feature store\u0026rdquo;‚Äîa concept new to me before joining‚Äîhas presented novel challenges.\u003c/p\u003e","title":"Statistics as the Foundation for Data Engineering: A Software Engineer's Transition"},{"content":"About Me I\u0026rsquo;m Claudio Melo, a software and data engineer passionate about building systems that work at scale.\nWhat I Do I focus on the intersection of software engineering and data systems:\nDistributed Systems - Building and optimizing large-scale data processing systems Apache Spark - Performance tuning, architecture, and best practices Data Architecture - Designing robust data platforms and pipelines Software Engineering - Writing maintainable, performant code System Design - Trade-offs, scalability, and reliability patterns Philosophy I believe that good engineering is about:\n‚úÖ Understanding trade-offs deeply before making decisions ‚úÖ Writing code that communicates intent clearly ‚úÖ Documenting the reasoning behind architectural choices ‚úÖ Learning continuously and sharing knowledge ‚úÖ Building systems that are simple, but not simplistic About This Blog This blog explores:\nüìö Fundamental principles that transcend specific technologies üéØ System design patterns and architectural decisions ‚öñÔ∏è Trade-offs in building real-world systems üöÄ Practical implementations with working code üß† Mental models for solving complex problems I write about topics like distributed data processing, system performance, software architecture, and the principles that make systems reliable and maintainable.\nContact üíº LinkedIn üêô GitHub Note: All opinions expressed here are my own and do not represent those of my employers, past or present.\n","permalink":"http://localhost:1313/about/","summary":"About Claudio Melo and this blog","title":"About"}]